import { decode, encode } from "../encoding/utf8.ts";
import { hasOwnProperty } from "../_util/has_own_property.ts";
import { BufReader, BufWriter } from "../io/bufio.ts";
import { readLong, readShort, sliceLongToBytes } from "../io/ioutil.ts";
import { Sha1 } from "../hash/sha1.ts";
import { writeResponse } from "../http/_io.ts";
import { TextProtoReader } from "../textproto/mod.ts";
import { deferred } from "../async/deferred.ts";
import { assert } from "../_util/assert.ts";
import { concat } from "../bytes/mod.ts";
export var OpCode;
(function (OpCode) {
    OpCode[OpCode["Continue"] = 0] = "Continue";
    OpCode[OpCode["TextFrame"] = 1] = "TextFrame";
    OpCode[OpCode["BinaryFrame"] = 2] = "BinaryFrame";
    OpCode[OpCode["Close"] = 8] = "Close";
    OpCode[OpCode["Ping"] = 9] = "Ping";
    OpCode[OpCode["Pong"] = 10] = "Pong";
})(OpCode || (OpCode = {}));
export function isWebSocketCloseEvent(a) {
    return hasOwnProperty(a, "code");
}
export function isWebSocketPingEvent(a) {
    return Array.isArray(a) && a[0] === "ping" && a[1] instanceof Uint8Array;
}
export function isWebSocketPongEvent(a) {
    return Array.isArray(a) && a[0] === "pong" && a[1] instanceof Uint8Array;
}
export function unmask(payload, mask) {
    if (mask) {
        for (let i = 0, len = payload.length; i < len; i++) {
            payload[i] ^= mask[i & 3];
        }
    }
}
export async function writeFrame(frame, writer) {
    const payloadLength = frame.payload.byteLength;
    let header;
    const hasMask = frame.mask ? 0x80 : 0;
    if (frame.mask && frame.mask.byteLength !== 4) {
        throw new Error("invalid mask. mask must be 4 bytes: length=" + frame.mask.byteLength);
    }
    if (payloadLength < 126) {
        header = new Uint8Array([0x80 | frame.opcode, hasMask | payloadLength]);
    }
    else if (payloadLength < 0xffff) {
        header = new Uint8Array([
            0x80 | frame.opcode,
            hasMask | 0b01111110,
            payloadLength >>> 8,
            payloadLength & 0x00ff,
        ]);
    }
    else {
        header = new Uint8Array([
            0x80 | frame.opcode,
            hasMask | 0b01111111,
            ...sliceLongToBytes(payloadLength),
        ]);
    }
    if (frame.mask) {
        header = concat(header, frame.mask);
    }
    unmask(frame.payload, frame.mask);
    header = concat(header, frame.payload);
    const w = BufWriter.create(writer);
    await w.write(header);
    await w.flush();
}
export async function readFrame(buf) {
    let b = await buf.readByte();
    assert(b !== null);
    let isLastFrame = false;
    switch (b >>> 4) {
        case 0b1000:
            isLastFrame = true;
            break;
        case 0b0000:
            isLastFrame = false;
            break;
        default:
            throw new Error("invalid signature");
    }
    const opcode = b & 0x0f;
    b = await buf.readByte();
    assert(b !== null);
    const hasMask = b >>> 7;
    let payloadLength = b & 0b01111111;
    if (payloadLength === 126) {
        const l = await readShort(buf);
        assert(l !== null);
        payloadLength = l;
    }
    else if (payloadLength === 127) {
        const l = await readLong(buf);
        assert(l !== null);
        payloadLength = Number(l);
    }
    let mask;
    if (hasMask) {
        mask = new Uint8Array(4);
        assert((await buf.readFull(mask)) !== null);
    }
    const payload = new Uint8Array(payloadLength);
    assert((await buf.readFull(payload)) !== null);
    return {
        isLastFrame,
        opcode,
        mask,
        payload,
    };
}
class WebSocketImpl {
    conn;
    mask;
    bufReader;
    bufWriter;
    sendQueue = [];
    constructor({ conn, bufReader, bufWriter, mask, }) {
        this.conn = conn;
        this.mask = mask;
        this.bufReader = bufReader || new BufReader(conn);
        this.bufWriter = bufWriter || new BufWriter(conn);
    }
    async *[Symbol.asyncIterator]() {
        let frames = [];
        let payloadsLength = 0;
        while (!this._isClosed) {
            let frame;
            try {
                frame = await readFrame(this.bufReader);
            }
            catch (e) {
                this.ensureSocketClosed();
                break;
            }
            unmask(frame.payload, frame.mask);
            switch (frame.opcode) {
                case OpCode.TextFrame:
                case OpCode.BinaryFrame:
                case OpCode.Continue:
                    frames.push(frame);
                    payloadsLength += frame.payload.length;
                    if (frame.isLastFrame) {
                        const concat = new Uint8Array(payloadsLength);
                        let offs = 0;
                        for (const frame of frames) {
                            concat.set(frame.payload, offs);
                            offs += frame.payload.length;
                        }
                        if (frames[0].opcode === OpCode.TextFrame) {
                            yield decode(concat);
                        }
                        else {
                            yield concat;
                        }
                        frames = [];
                        payloadsLength = 0;
                    }
                    break;
                case OpCode.Close: {
                    const code = (frame.payload[0] << 8) | frame.payload[1];
                    const reason = decode(frame.payload.subarray(2, frame.payload.length));
                    await this.close(code, reason);
                    yield { code, reason };
                    return;
                }
                case OpCode.Ping:
                    await this.enqueue({
                        opcode: OpCode.Pong,
                        payload: frame.payload,
                        isLastFrame: true,
                    });
                    yield ["ping", frame.payload];
                    break;
                case OpCode.Pong:
                    yield ["pong", frame.payload];
                    break;
                default:
            }
        }
    }
    dequeue() {
        const [entry] = this.sendQueue;
        if (!entry)
            return;
        if (this._isClosed)
            return;
        const { d, frame } = entry;
        writeFrame(frame, this.bufWriter)
            .then(() => d.resolve())
            .catch((e) => d.reject(e))
            .finally(() => {
            this.sendQueue.shift();
            this.dequeue();
        });
    }
    enqueue(frame) {
        if (this._isClosed) {
            throw new Deno.errors.ConnectionReset("Socket has already been closed");
        }
        const d = deferred();
        this.sendQueue.push({ d, frame });
        if (this.sendQueue.length === 1) {
            this.dequeue();
        }
        return d;
    }
    send(data) {
        const opcode = typeof data === "string"
            ? OpCode.TextFrame
            : OpCode.BinaryFrame;
        const payload = typeof data === "string" ? encode(data) : data;
        const isLastFrame = true;
        const frame = {
            isLastFrame,
            opcode,
            payload,
            mask: this.mask,
        };
        return this.enqueue(frame);
    }
    ping(data = "") {
        const payload = typeof data === "string" ? encode(data) : data;
        const frame = {
            isLastFrame: true,
            opcode: OpCode.Ping,
            mask: this.mask,
            payload,
        };
        return this.enqueue(frame);
    }
    _isClosed = false;
    get isClosed() {
        return this._isClosed;
    }
    async close(code = 1000, reason) {
        try {
            const header = [code >>> 8, code & 0x00ff];
            let payload;
            if (reason) {
                const reasonBytes = encode(reason);
                payload = new Uint8Array(2 + reasonBytes.byteLength);
                payload.set(header);
                payload.set(reasonBytes, 2);
            }
            else {
                payload = new Uint8Array(header);
            }
            await this.enqueue({
                isLastFrame: true,
                opcode: OpCode.Close,
                mask: this.mask,
                payload,
            });
        }
        catch (e) {
            throw e;
        }
        finally {
            this.ensureSocketClosed();
        }
    }
    closeForce() {
        this.ensureSocketClosed();
    }
    ensureSocketClosed() {
        if (this.isClosed)
            return;
        try {
            this.conn.close();
        }
        catch (e) {
            console.error(e);
        }
        finally {
            this._isClosed = true;
            const rest = this.sendQueue;
            this.sendQueue = [];
            rest.forEach((e) => e.d.reject(new Deno.errors.ConnectionReset("Socket has already been closed")));
        }
    }
}
export function acceptable(req) {
    const upgrade = req.headers.get("upgrade");
    if (!upgrade || upgrade.toLowerCase() !== "websocket") {
        return false;
    }
    const secKey = req.headers.get("sec-websocket-key");
    return (req.headers.has("sec-websocket-key") &&
        typeof secKey === "string" &&
        secKey.length > 0);
}
const kGUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
export function createSecAccept(nonce) {
    const sha1 = new Sha1();
    sha1.update(nonce + kGUID);
    const bytes = sha1.digest();
    return btoa(String.fromCharCode(...bytes));
}
export async function acceptWebSocket(req) {
    const { conn, headers, bufReader, bufWriter } = req;
    if (acceptable(req)) {
        const sock = new WebSocketImpl({ conn, bufReader, bufWriter });
        const secKey = headers.get("sec-websocket-key");
        if (typeof secKey !== "string") {
            throw new Error("sec-websocket-key is not provided");
        }
        const secAccept = createSecAccept(secKey);
        const newHeaders = new Headers({
            Upgrade: "websocket",
            Connection: "Upgrade",
            "Sec-WebSocket-Accept": secAccept,
        });
        const secProtocol = headers.get("sec-websocket-protocol");
        if (typeof secProtocol === "string") {
            newHeaders.set("Sec-WebSocket-Protocol", secProtocol);
        }
        const secVersion = headers.get("sec-websocket-version");
        if (typeof secVersion === "string") {
            newHeaders.set("Sec-WebSocket-Version", secVersion);
        }
        await writeResponse(bufWriter, {
            status: 101,
            headers: newHeaders,
        });
        return sock;
    }
    throw new Error("request is not acceptable");
}
const kSecChars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-.~_";
export function createSecKey() {
    let key = "";
    for (let i = 0; i < 16; i++) {
        const j = Math.floor(Math.random() * kSecChars.length);
        key += kSecChars[j];
    }
    return btoa(key);
}
export async function handshake(url, headers, bufReader, bufWriter) {
    const { hostname, pathname, search } = url;
    const key = createSecKey();
    if (!headers.has("host")) {
        headers.set("host", hostname);
    }
    headers.set("upgrade", "websocket");
    headers.set("connection", "upgrade");
    headers.set("sec-websocket-key", key);
    headers.set("sec-websocket-version", "13");
    let headerStr = `GET ${pathname}${search} HTTP/1.1\r\n`;
    for (const [key, value] of headers) {
        headerStr += `${key}: ${value}\r\n`;
    }
    headerStr += "\r\n";
    await bufWriter.write(encode(headerStr));
    await bufWriter.flush();
    const tpReader = new TextProtoReader(bufReader);
    const statusLine = await tpReader.readLine();
    if (statusLine === null) {
        throw new Deno.errors.UnexpectedEof();
    }
    const m = statusLine.match(/^(?<version>\S+) (?<statusCode>\S+) /);
    if (!m) {
        throw new Error("ws: invalid status line: " + statusLine);
    }
    assert(m.groups);
    const { version, statusCode } = m.groups;
    if (version !== "HTTP/1.1" || statusCode !== "101") {
        throw new Error(`ws: server didn't accept handshake: ` +
            `version=${version}, statusCode=${statusCode}`);
    }
    const responseHeaders = await tpReader.readMIMEHeader();
    if (responseHeaders === null) {
        throw new Deno.errors.UnexpectedEof();
    }
    const expectedSecAccept = createSecAccept(key);
    const secAccept = responseHeaders.get("sec-websocket-accept");
    if (secAccept !== expectedSecAccept) {
        throw new Error(`ws: unexpected sec-websocket-accept header: ` +
            `expected=${expectedSecAccept}, actual=${secAccept}`);
    }
}
export function createWebSocket(params) {
    return new WebSocketImpl(params);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9kLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsibW9kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDckQsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLDhCQUE4QixDQUFDO0FBQzlELE9BQU8sRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDdEQsT0FBTyxFQUFFLFFBQVEsRUFBRSxTQUFTLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUN4RSxPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDdkMsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQy9DLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUN0RCxPQUFPLEVBQVksUUFBUSxFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDMUQsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBQzVDLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUV6QyxNQUFNLENBQU4sSUFBWSxNQU9YO0FBUEQsV0FBWSxNQUFNO0lBQ2hCLDJDQUFjLENBQUE7SUFDZCw2Q0FBZSxDQUFBO0lBQ2YsaURBQWlCLENBQUE7SUFDakIscUNBQVcsQ0FBQTtJQUNYLG1DQUFVLENBQUE7SUFDVixvQ0FBVSxDQUFBO0FBQ1osQ0FBQyxFQVBXLE1BQU0sS0FBTixNQUFNLFFBT2pCO0FBZUQsTUFBTSxVQUFVLHFCQUFxQixDQUNuQyxDQUFpQjtJQUVqQixPQUFPLGNBQWMsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUM7QUFDbkMsQ0FBQztBQUtELE1BQU0sVUFBVSxvQkFBb0IsQ0FDbEMsQ0FBaUI7SUFFakIsT0FBTyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FB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LCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxOC0yMDIxIHRoZSBEZW5vIGF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIE1JVCBsaWNlbnNlLlxuaW1wb3J0IHsgZGVjb2RlLCBlbmNvZGUgfSBmcm9tIFwiLi4vZW5jb2RpbmcvdXRmOC50c1wiO1xuaW1wb3J0IHsgaGFzT3duUHJvcGVydHkgfSBmcm9tIFwiLi4vX3V0aWwvaGFzX293bl9wcm9wZXJ0eS50c1wiO1xuaW1wb3J0IHsgQnVmUmVhZGVyLCBCdWZXcml0ZXIgfSBmcm9tIFwiLi4vaW8vYnVmaW8udHNcIjtcbmltcG9ydCB7IHJlYWRMb25nLCByZWFkU2hvcnQsIHNsaWNlTG9uZ1RvQnl0ZXMgfSBmcm9tIFwiLi4vaW8vaW91dGlsLnRzXCI7XG5pbXBvcnQgeyBTaGExIH0gZnJvbSBcIi4uL2hhc2gvc2hhMS50c1wiO1xuaW1wb3J0IHsgd3JpdGVSZXNwb25zZSB9IGZyb20gXCIuLi9odHRwL19pby50c1wiO1xuaW1wb3J0IHsgVGV4dFByb3RvUmVhZGVyIH0gZnJvbSBcIi4uL3RleHRwcm90by9tb2QudHNcIjtcbmltcG9ydCB7IERlZmVycmVkLCBkZWZlcnJlZCB9IGZyb20gXCIuLi9hc3luYy9kZWZlcnJlZC50c1wiO1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSBcIi4uL191dGlsL2Fzc2VydC50c1wiO1xuaW1wb3J0IHsgY29uY2F0IH0gZnJvbSBcIi4uL2J5dGVzL21vZC50c1wiO1xuXG5leHBvcnQgZW51bSBPcENvZGUge1xuICBDb250aW51ZSA9IDB4MCxcbiAgVGV4dEZyYW1lID0gMHgxLFxuICBCaW5hcnlGcmFtZSA9IDB4MixcbiAgQ2xvc2UgPSAweDgsXG4gIFBpbmcgPSAweDksXG4gIFBvbmcgPSAweGEsXG59XG5cbmV4cG9ydCB0eXBlIFdlYlNvY2tldEV2ZW50ID1cbiAgfCBzdHJpbmdcbiAgfCBVaW50OEFycmF5XG4gIHwgV2ViU29ja2V0Q2xvc2VFdmVudCAvLyBSZWNlaXZlZCBhZnRlciBjbG9zaW5nIGNvbm5lY3Rpb24gZmluaXNoZWQuXG4gIHwgV2ViU29ja2V0UGluZ0V2ZW50IC8vIFJlY2VpdmVkIGFmdGVyIHBvbmcgZnJhbWUgcmVzcG9uZGVkLlxuICB8IFdlYlNvY2tldFBvbmdFdmVudDtcblxuZXhwb3J0IGludGVyZmFjZSBXZWJTb2NrZXRDbG9zZUV2ZW50IHtcbiAgY29kZTogbnVtYmVyO1xuICByZWFzb24/OiBzdHJpbmc7XG59XG5cbi8qKiBSZXR1cm5zIHRydWUgaWYgaW5wdXQgdmFsdWUgaXMgYSBXZWJTb2NrZXRDbG9zZUV2ZW50LCBmYWxzZSBvdGhlcndpc2UuICovXG5leHBvcnQgZnVuY3Rpb24gaXNXZWJTb2NrZXRDbG9zZUV2ZW50KFxuICBhOiBXZWJTb2NrZXRFdmVudCxcbik6IGEgaXMgV2ViU29ja2V0Q2xvc2VFdmVudCB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eShhLCBcImNvZGVcIik7XG59XG5cbmV4cG9ydCB0eXBlIFdlYlNvY2tldFBpbmdFdmVudCA9IFtcInBpbmdcIiwgVWludDhBcnJheV07XG5cbi8qKiBSZXR1cm5zIHRydWUgaWYgaW5wdXQgdmFsdWUgaXMgYSBXZWJTb2NrZXRQaW5nRXZlbnQsIGZhbHNlIG90aGVyd2lzZS4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1dlYlNvY2tldFBpbmdFdmVudChcbiAgYTogV2ViU29ja2V0RXZlbnQsXG4pOiBhIGlzIFdlYlNvY2tldFBpbmdFdmVudCB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGEpICYmIGFbMF0gPT09IFwicGluZ1wiICYmIGFbMV0gaW5zdGFuY2VvZiBVaW50OEFycmF5O1xufVxuXG5leHBvcnQgdHlwZSBXZWJTb2NrZXRQb25nRXZlbnQgPSBbXCJwb25nXCIsIFVpbnQ4QXJyYXldO1xuXG4vKiogUmV0dXJucyB0cnVlIGlmIGlucHV0IHZhbHVlIGlzIGEgV2ViU29ja2V0UG9uZ0V2ZW50LCBmYWxzZSBvdGhlcndpc2UuICovXG5leHBvcnQgZnVuY3Rpb24gaXNXZWJTb2NrZXRQb25nRXZlbnQoXG4gIGE6IFdlYlNvY2tldEV2ZW50LFxuKTogYSBpcyBXZWJTb2NrZXRQb25nRXZlbnQge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhKSAmJiBhWzBdID09PSBcInBvbmdcIiAmJiBhWzFdIGluc3RhbmNlb2YgVWludDhBcnJheTtcbn1cblxuZXhwb3J0IHR5cGUgV2ViU29ja2V0TWVzc2FnZSA9IHN0cmluZyB8IFVpbnQ4QXJyYXk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgV2ViU29ja2V0RnJhbWUge1xuICBpc0xhc3RGcmFtZTogYm9vbGVhbjtcbiAgb3Bjb2RlOiBPcENvZGU7XG4gIG1hc2s/OiBVaW50OEFycmF5O1xuICBwYXlsb2FkOiBVaW50OEFycmF5O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFdlYlNvY2tldCBleHRlbmRzIEFzeW5jSXRlcmFibGU8V2ViU29ja2V0RXZlbnQ+IHtcbiAgcmVhZG9ubHkgY29ubjogRGVuby5Db25uO1xuICByZWFkb25seSBpc0Nsb3NlZDogYm9vbGVhbjtcblxuICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk6IEFzeW5jSXRlcmFibGVJdGVyYXRvcjxXZWJTb2NrZXRFdmVudD47XG5cbiAgLyoqXG4gICAqIEB0aHJvd3MgYERlbm8uZXJyb3JzLkNvbm5lY3Rpb25SZXNldGBcbiAgICovXG4gIHNlbmQoZGF0YTogV2ViU29ja2V0TWVzc2FnZSk6IFByb21pc2U8dm9pZD47XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBkYXRhXG4gICAqIEB0aHJvd3MgYERlbm8uZXJyb3JzLkNvbm5lY3Rpb25SZXNldGBcbiAgICovXG4gIHBpbmcoZGF0YT86IFdlYlNvY2tldE1lc3NhZ2UpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKiBDbG9zZSBjb25uZWN0aW9uIGFmdGVyIHNlbmRpbmcgY2xvc2UgZnJhbWUgdG8gcGVlci5cbiAgICogVGhpcyBpcyBjYW5vbmljYWwgd2F5IG9mIGRpc2Nvbm5lY3Rpb24gYnV0IGl0IG1heSBoYW5nIGJlY2F1c2Ugb2YgcGVlcidzIHJlc3BvbnNlIGRlbGF5LlxuICAgKiBEZWZhdWx0IGNsb3NlIGNvZGUgaXMgMTAwMCAoTm9ybWFsIENsb3N1cmUpXG4gICAqIEB0aHJvd3MgYERlbm8uZXJyb3JzLkNvbm5lY3Rpb25SZXNldGBcbiAgICovXG4gIGNsb3NlKCk6IFByb21pc2U8dm9pZD47XG4gIGNsb3NlKGNvZGU6IG51bWJlcik6IFByb21pc2U8dm9pZD47XG4gIGNsb3NlKGNvZGU6IG51bWJlciwgcmVhc29uOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKiBDbG9zZSBjb25uZWN0aW9uIGZvcmNlbHkgd2l0aG91dCBzZW5kaW5nIGNsb3NlIGZyYW1lIHRvIHBlZXIuXG4gICAqICBUaGlzIGlzIGJhc2ljYWxseSB1bmRlc2lyYWJsZSB3YXkgb2YgZGlzY29ubmVjdGlvbi4gVXNlIGNhcmVmdWxseS4gKi9cbiAgY2xvc2VGb3JjZSgpOiB2b2lkO1xufVxuXG4vKiogVW5tYXNrIG1hc2tlZCB3ZWJzb2NrZXQgcGF5bG9hZCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVubWFzayhwYXlsb2FkOiBVaW50OEFycmF5LCBtYXNrPzogVWludDhBcnJheSk6IHZvaWQge1xuICBpZiAobWFzaykge1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBwYXlsb2FkLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBwYXlsb2FkW2ldIF49IG1hc2tbaSAmIDNdO1xuICAgIH1cbiAgfVxufVxuXG4vKiogV3JpdGUgV2ViU29ja2V0IGZyYW1lIHRvIGlucHV0dGVkIHdyaXRlci4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB3cml0ZUZyYW1lKFxuICBmcmFtZTogV2ViU29ja2V0RnJhbWUsXG4gIHdyaXRlcjogRGVuby5Xcml0ZXIsXG4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgY29uc3QgcGF5bG9hZExlbmd0aCA9IGZyYW1lLnBheWxvYWQuYnl0ZUxlbmd0aDtcbiAgbGV0IGhlYWRlcjogVWludDhBcnJheTtcbiAgY29uc3QgaGFzTWFzayA9IGZyYW1lLm1hc2sgPyAweDgwIDogMDtcbiAgaWYgKGZyYW1lLm1hc2sgJiYgZnJhbWUubWFzay5ieXRlTGVuZ3RoICE9PSA0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJpbnZhbGlkIG1hc2suIG1hc2sgbXVzdCBiZSA0IGJ5dGVzOiBsZW5ndGg9XCIgKyBmcmFtZS5tYXNrLmJ5dGVMZW5ndGgsXG4gICAgKTtcbiAgfVxuICBpZiAocGF5bG9hZExlbmd0aCA8IDEyNikge1xuICAgIGhlYWRlciA9IG5ldyBVaW50OEFycmF5KFsweDgwIHwgZnJhbWUub3Bjb2RlLCBoYXNNYXNrIHwgcGF5bG9hZExlbmd0aF0pO1xuICB9IGVsc2UgaWYgKHBheWxvYWRMZW5ndGggPCAweGZmZmYpIHtcbiAgICBoZWFkZXIgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAweDgwIHwgZnJhbWUub3Bjb2RlLFxuICAgICAgaGFzTWFzayB8IDBiMDExMTExMTAsXG4gICAgICBwYXlsb2FkTGVuZ3RoID4+PiA4LFxuICAgICAgcGF5bG9hZExlbmd0aCAmIDB4MDBmZixcbiAgICBdKTtcbiAgfSBlbHNlIHtcbiAgICBoZWFkZXIgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAweDgwIHwgZnJhbWUub3Bjb2RlLFxuICAgICAgaGFzTWFzayB8IDBiMDExMTExMTEsXG4gICAgICAuLi5zbGljZUxvbmdUb0J5dGVzKHBheWxvYWRMZW5ndGgpLFxuICAgIF0pO1xuICB9XG4gIGlmIChmcmFtZS5tYXNrKSB7XG4gICAgaGVhZGVyID0gY29uY2F0KGhlYWRlciwgZnJhbWUubWFzayk7XG4gIH1cbiAgdW5tYXNrKGZyYW1lLnBheWxvYWQsIGZyYW1lLm1hc2spO1xuICBoZWFkZXIgPSBjb25jYXQoaGVhZGVyLCBmcmFtZS5wYXlsb2FkKTtcbiAgY29uc3QgdyA9IEJ1ZldyaXRlci5jcmVhdGUod3JpdGVyKTtcbiAgYXdhaXQgdy53cml0ZShoZWFkZXIpO1xuICBhd2FpdCB3LmZsdXNoKCk7XG59XG5cbi8qKiBSZWFkIHdlYnNvY2tldCBmcmFtZSBmcm9tIGdpdmVuIEJ1ZlJlYWRlclxuICogQHRocm93cyBgRGVuby5lcnJvcnMuVW5leHBlY3RlZEVvZmAgV2hlbiBwZWVyIGNsb3NlZCBjb25uZWN0aW9uIHdpdGhvdXQgY2xvc2UgZnJhbWVcbiAqIEB0aHJvd3MgYEVycm9yYCBGcmFtZSBpcyBpbnZhbGlkXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWFkRnJhbWUoYnVmOiBCdWZSZWFkZXIpOiBQcm9taXNlPFdlYlNvY2tldEZyYW1lPiB7XG4gIGxldCBiID0gYXdhaXQgYnVmLnJlYWRCeXRlKCk7XG4gIGFzc2VydChiICE9PSBudWxsKTtcbiAgbGV0IGlzTGFzdEZyYW1lID0gZmFsc2U7XG4gIHN3aXRjaCAoYiA+Pj4gNCkge1xuICAgIGNhc2UgMGIxMDAwOlxuICAgICAgaXNMYXN0RnJhbWUgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAwYjAwMDA6XG4gICAgICBpc0xhc3RGcmFtZSA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgc2lnbmF0dXJlXCIpO1xuICB9XG4gIGNvbnN0IG9wY29kZSA9IGIgJiAweDBmO1xuICAvLyBoYXNfbWFzayAmIHBheWxvYWRcbiAgYiA9IGF3YWl0IGJ1Zi5yZWFkQnl0ZSgpO1xuICBhc3NlcnQoYiAhPT0gbnVsbCk7XG4gIGNvbnN0IGhhc01hc2sgPSBiID4+PiA3O1xuICBsZXQgcGF5bG9hZExlbmd0aCA9IGIgJiAwYjAxMTExMTExO1xuICBpZiAocGF5bG9hZExlbmd0aCA9PT0gMTI2KSB7XG4gICAgY29uc3QgbCA9IGF3YWl0IHJlYWRTaG9ydChidWYpO1xuICAgIGFzc2VydChsICE9PSBudWxsKTtcbiAgICBwYXlsb2FkTGVuZ3RoID0gbDtcbiAgfSBlbHNlIGlmIChwYXlsb2FkTGVuZ3RoID09PSAxMjcpIHtcbiAgICBjb25zdCBsID0gYXdhaXQgcmVhZExvbmcoYnVmKTtcbiAgICBhc3NlcnQobCAhPT0gbnVsbCk7XG4gICAgcGF5bG9hZExlbmd0aCA9IE51bWJlcihsKTtcbiAgfVxuICAvLyBtYXNrXG4gIGxldCBtYXNrOiBVaW50OEFycmF5IHwgdW5kZWZpbmVkO1xuICBpZiAoaGFzTWFzaykge1xuICAgIG1hc2sgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICBhc3NlcnQoKGF3YWl0IGJ1Zi5yZWFkRnVsbChtYXNrKSkgIT09IG51bGwpO1xuICB9XG4gIC8vIHBheWxvYWRcbiAgY29uc3QgcGF5bG9hZCA9IG5ldyBVaW50OEFycmF5KHBheWxvYWRMZW5ndGgpO1xuICBhc3NlcnQoKGF3YWl0IGJ1Zi5yZWFkRnVsbChwYXlsb2FkKSkgIT09IG51bGwpO1xuICByZXR1cm4ge1xuICAgIGlzTGFzdEZyYW1lLFxuICAgIG9wY29kZSxcbiAgICBtYXNrLFxuICAgIHBheWxvYWQsXG4gIH07XG59XG5cbmNsYXNzIFdlYlNvY2tldEltcGwgaW1wbGVtZW50cyBXZWJTb2NrZXQge1xuICByZWFkb25seSBjb25uOiBEZW5vLkNvbm47XG4gIHByaXZhdGUgcmVhZG9ubHkgbWFzaz86IFVpbnQ4QXJyYXk7XG4gIHByaXZhdGUgcmVhZG9ubHkgYnVmUmVhZGVyOiBCdWZSZWFkZXI7XG4gIHByaXZhdGUgcmVhZG9ubHkgYnVmV3JpdGVyOiBCdWZXcml0ZXI7XG4gIHByaXZhdGUgc2VuZFF1ZXVlOiBBcnJheTx7XG4gICAgZnJhbWU6IFdlYlNvY2tldEZyYW1lO1xuICAgIGQ6IERlZmVycmVkPHZvaWQ+O1xuICB9PiA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjb25uLFxuICAgIGJ1ZlJlYWRlcixcbiAgICBidWZXcml0ZXIsXG4gICAgbWFzayxcbiAgfToge1xuICAgIGNvbm46IERlbm8uQ29ubjtcbiAgICBidWZSZWFkZXI/OiBCdWZSZWFkZXI7XG4gICAgYnVmV3JpdGVyPzogQnVmV3JpdGVyO1xuICAgIG1hc2s/OiBVaW50OEFycmF5O1xuICB9KSB7XG4gICAgdGhpcy5jb25uID0gY29ubjtcbiAgICB0aGlzLm1hc2sgPSBtYXNrO1xuICAgIHRoaXMuYnVmUmVhZGVyID0gYnVmUmVhZGVyIHx8IG5ldyBCdWZSZWFkZXIoY29ubik7XG4gICAgdGhpcy5idWZXcml0ZXIgPSBidWZXcml0ZXIgfHwgbmV3IEJ1ZldyaXRlcihjb25uKTtcbiAgfVxuXG4gIGFzeW5jICpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk6IEFzeW5jSXRlcmFibGVJdGVyYXRvcjxXZWJTb2NrZXRFdmVudD4ge1xuICAgIGxldCBmcmFtZXM6IFdlYlNvY2tldEZyYW1lW10gPSBbXTtcbiAgICBsZXQgcGF5bG9hZHNMZW5ndGggPSAwO1xuICAgIHdoaWxlICghdGhpcy5faXNDbG9zZWQpIHtcbiAgICAgIGxldCBmcmFtZTogV2ViU29ja2V0RnJhbWU7XG4gICAgICB0cnkge1xuICAgICAgICBmcmFtZSA9IGF3YWl0IHJlYWRGcmFtZSh0aGlzLmJ1ZlJlYWRlcik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlU29ja2V0Q2xvc2VkKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdW5tYXNrKGZyYW1lLnBheWxvYWQsIGZyYW1lLm1hc2spO1xuICAgICAgc3dpdGNoIChmcmFtZS5vcGNvZGUpIHtcbiAgICAgICAgY2FzZSBPcENvZGUuVGV4dEZyYW1lOlxuICAgICAgICBjYXNlIE9wQ29kZS5CaW5hcnlGcmFtZTpcbiAgICAgICAgY2FzZSBPcENvZGUuQ29udGludWU6XG4gICAgICAgICAgZnJhbWVzLnB1c2goZnJhbWUpO1xuICAgICAgICAgIHBheWxvYWRzTGVuZ3RoICs9IGZyYW1lLnBheWxvYWQubGVuZ3RoO1xuICAgICAgICAgIGlmIChmcmFtZS5pc0xhc3RGcmFtZSkge1xuICAgICAgICAgICAgY29uc3QgY29uY2F0ID0gbmV3IFVpbnQ4QXJyYXkocGF5bG9hZHNMZW5ndGgpO1xuICAgICAgICAgICAgbGV0IG9mZnMgPSAwO1xuICAgICAgICAgICAgZm9yIChjb25zdCBmcmFtZSBvZiBmcmFtZXMpIHtcbiAgICAgICAgICAgICAgY29uY2F0LnNldChmcmFtZS5wYXlsb2FkLCBvZmZzKTtcbiAgICAgICAgICAgICAgb2ZmcyArPSBmcmFtZS5wYXlsb2FkLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmcmFtZXNbMF0ub3Bjb2RlID09PSBPcENvZGUuVGV4dEZyYW1lKSB7XG4gICAgICAgICAgICAgIC8vIHRleHRcbiAgICAgICAgICAgICAgeWllbGQgZGVjb2RlKGNvbmNhdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBiaW5hcnlcbiAgICAgICAgICAgICAgeWllbGQgY29uY2F0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnJhbWVzID0gW107XG4gICAgICAgICAgICBwYXlsb2Fkc0xlbmd0aCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIE9wQ29kZS5DbG9zZToge1xuICAgICAgICAgIC8vIFsweDEyLCAweDM0XSAtPiAweDEyMzRcbiAgICAgICAgICBjb25zdCBjb2RlID0gKGZyYW1lLnBheWxvYWRbMF0gPDwgOCkgfCBmcmFtZS5wYXlsb2FkWzFdO1xuICAgICAgICAgIGNvbnN0IHJlYXNvbiA9IGRlY29kZShcbiAgICAgICAgICAgIGZyYW1lLnBheWxvYWQuc3ViYXJyYXkoMiwgZnJhbWUucGF5bG9hZC5sZW5ndGgpLFxuICAgICAgICAgICk7XG4gICAgICAgICAgYXdhaXQgdGhpcy5jbG9zZShjb2RlLCByZWFzb24pO1xuICAgICAgICAgIHlpZWxkIHsgY29kZSwgcmVhc29uIH07XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgT3BDb2RlLlBpbmc6XG4gICAgICAgICAgYXdhaXQgdGhpcy5lbnF1ZXVlKHtcbiAgICAgICAgICAgIG9wY29kZTogT3BDb2RlLlBvbmcsXG4gICAgICAgICAgICBwYXlsb2FkOiBmcmFtZS5wYXlsb2FkLFxuICAgICAgICAgICAgaXNMYXN0RnJhbWU6IHRydWUsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgeWllbGQgW1wicGluZ1wiLCBmcmFtZS5wYXlsb2FkXSBhcyBXZWJTb2NrZXRQaW5nRXZlbnQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgT3BDb2RlLlBvbmc6XG4gICAgICAgICAgeWllbGQgW1wicG9uZ1wiLCBmcmFtZS5wYXlsb2FkXSBhcyBXZWJTb2NrZXRQb25nRXZlbnQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBkZXF1ZXVlKCk6IHZvaWQge1xuICAgIGNvbnN0IFtlbnRyeV0gPSB0aGlzLnNlbmRRdWV1ZTtcbiAgICBpZiAoIWVudHJ5KSByZXR1cm47XG4gICAgaWYgKHRoaXMuX2lzQ2xvc2VkKSByZXR1cm47XG4gICAgY29uc3QgeyBkLCBmcmFtZSB9ID0gZW50cnk7XG4gICAgd3JpdGVGcmFtZShmcmFtZSwgdGhpcy5idWZXcml0ZXIpXG4gICAgICAudGhlbigoKSA9PiBkLnJlc29sdmUoKSlcbiAgICAgIC5jYXRjaCgoZSkgPT4gZC5yZWplY3QoZSkpXG4gICAgICAuZmluYWxseSgoKSA9PiB7XG4gICAgICAgIHRoaXMuc2VuZFF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIHRoaXMuZGVxdWV1ZSgpO1xuICAgICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGVucXVldWUoZnJhbWU6IFdlYlNvY2tldEZyYW1lKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHRoaXMuX2lzQ2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRGVuby5lcnJvcnMuQ29ubmVjdGlvblJlc2V0KFwiU29ja2V0IGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkXCIpO1xuICAgIH1cbiAgICBjb25zdCBkID0gZGVmZXJyZWQ8dm9pZD4oKTtcbiAgICB0aGlzLnNlbmRRdWV1ZS5wdXNoKHsgZCwgZnJhbWUgfSk7XG4gICAgaWYgKHRoaXMuc2VuZFF1ZXVlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdGhpcy5kZXF1ZXVlKCk7XG4gICAgfVxuICAgIHJldHVybiBkO1xuICB9XG5cbiAgc2VuZChkYXRhOiBXZWJTb2NrZXRNZXNzYWdlKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3Qgb3Bjb2RlID0gdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCJcbiAgICAgID8gT3BDb2RlLlRleHRGcmFtZVxuICAgICAgOiBPcENvZGUuQmluYXJ5RnJhbWU7XG4gICAgY29uc3QgcGF5bG9hZCA9IHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiID8gZW5jb2RlKGRhdGEpIDogZGF0YTtcbiAgICBjb25zdCBpc0xhc3RGcmFtZSA9IHRydWU7XG4gICAgY29uc3QgZnJhbWUgPSB7XG4gICAgICBpc0xhc3RGcmFtZSxcbiAgICAgIG9wY29kZSxcbiAgICAgIHBheWxvYWQsXG4gICAgICBtYXNrOiB0aGlzLm1hc2ssXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5lbnF1ZXVlKGZyYW1lKTtcbiAgfVxuXG4gIHBpbmcoZGF0YTogV2ViU29ja2V0TWVzc2FnZSA9IFwiXCIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBwYXlsb2FkID0gdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgPyBlbmNvZGUoZGF0YSkgOiBkYXRhO1xuICAgIGNvbnN0IGZyYW1lID0ge1xuICAgICAgaXNMYXN0RnJhbWU6IHRydWUsXG4gICAgICBvcGNvZGU6IE9wQ29kZS5QaW5nLFxuICAgICAgbWFzazogdGhpcy5tYXNrLFxuICAgICAgcGF5bG9hZCxcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLmVucXVldWUoZnJhbWUpO1xuICB9XG5cbiAgcHJpdmF0ZSBfaXNDbG9zZWQgPSBmYWxzZTtcbiAgZ2V0IGlzQ2xvc2VkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9pc0Nsb3NlZDtcbiAgfVxuXG4gIGFzeW5jIGNsb3NlKGNvZGUgPSAxMDAwLCByZWFzb24/OiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgaGVhZGVyID0gW2NvZGUgPj4+IDgsIGNvZGUgJiAweDAwZmZdO1xuICAgICAgbGV0IHBheWxvYWQ6IFVpbnQ4QXJyYXk7XG4gICAgICBpZiAocmVhc29uKSB7XG4gICAgICAgIGNvbnN0IHJlYXNvbkJ5dGVzID0gZW5jb2RlKHJlYXNvbik7XG4gICAgICAgIHBheWxvYWQgPSBuZXcgVWludDhBcnJheSgyICsgcmVhc29uQnl0ZXMuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHBheWxvYWQuc2V0KGhlYWRlcik7XG4gICAgICAgIHBheWxvYWQuc2V0KHJlYXNvbkJ5dGVzLCAyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBheWxvYWQgPSBuZXcgVWludDhBcnJheShoZWFkZXIpO1xuICAgICAgfVxuICAgICAgYXdhaXQgdGhpcy5lbnF1ZXVlKHtcbiAgICAgICAgaXNMYXN0RnJhbWU6IHRydWUsXG4gICAgICAgIG9wY29kZTogT3BDb2RlLkNsb3NlLFxuICAgICAgICBtYXNrOiB0aGlzLm1hc2ssXG4gICAgICAgIHBheWxvYWQsXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmVuc3VyZVNvY2tldENsb3NlZCgpO1xuICAgIH1cbiAgfVxuXG4gIGNsb3NlRm9yY2UoKTogdm9pZCB7XG4gICAgdGhpcy5lbnN1cmVTb2NrZXRDbG9zZWQoKTtcbiAgfVxuXG4gIHByaXZhdGUgZW5zdXJlU29ja2V0Q2xvc2VkKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmlzQ2xvc2VkKSByZXR1cm47XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuY29ubi5jbG9zZSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuX2lzQ2xvc2VkID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHJlc3QgPSB0aGlzLnNlbmRRdWV1ZTtcbiAgICAgIHRoaXMuc2VuZFF1ZXVlID0gW107XG4gICAgICByZXN0LmZvckVhY2goKGUpID0+XG4gICAgICAgIGUuZC5yZWplY3QoXG4gICAgICAgICAgbmV3IERlbm8uZXJyb3JzLkNvbm5lY3Rpb25SZXNldChcIlNvY2tldCBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZFwiKSxcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqIFJldHVybnMgdHJ1ZSBpZiBpbnB1dCBoZWFkZXJzIGFyZSB1c2FibGUgZm9yIFdlYlNvY2tldCwgb3RoZXJ3aXNlIGZhbHNlLiAgKi9cbmV4cG9ydCBmdW5jdGlvbiBhY2NlcHRhYmxlKHJlcTogeyBoZWFkZXJzOiBIZWFkZXJzIH0pOiBib29sZWFuIHtcbiAgY29uc3QgdXBncmFkZSA9IHJlcS5oZWFkZXJzLmdldChcInVwZ3JhZGVcIik7XG4gIGlmICghdXBncmFkZSB8fCB1cGdyYWRlLnRvTG93ZXJDYXNlKCkgIT09IFwid2Vic29ja2V0XCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qgc2VjS2V5ID0gcmVxLmhlYWRlcnMuZ2V0KFwic2VjLXdlYnNvY2tldC1rZXlcIik7XG4gIHJldHVybiAoXG4gICAgcmVxLmhlYWRlcnMuaGFzKFwic2VjLXdlYnNvY2tldC1rZXlcIikgJiZcbiAgICB0eXBlb2Ygc2VjS2V5ID09PSBcInN0cmluZ1wiICYmXG4gICAgc2VjS2V5Lmxlbmd0aCA+IDBcbiAgKTtcbn1cblxuY29uc3Qga0dVSUQgPSBcIjI1OEVBRkE1LUU5MTQtNDdEQS05NUNBLUM1QUIwREM4NUIxMVwiO1xuXG4vKiogQ3JlYXRlIHZhbHVlIG9mIFNlYy1XZWJTb2NrZXQtQWNjZXB0IGhlYWRlciBmcm9tIGlucHV0dGVkIG5vbmNlLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNlY0FjY2VwdChub25jZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3Qgc2hhMSA9IG5ldyBTaGExKCk7XG4gIHNoYTEudXBkYXRlKG5vbmNlICsga0dVSUQpO1xuICBjb25zdCBieXRlcyA9IHNoYTEuZGlnZXN0KCk7XG4gIHJldHVybiBidG9hKFN0cmluZy5mcm9tQ2hhckNvZGUoLi4uYnl0ZXMpKTtcbn1cblxuLyoqIFVwZ3JhZGUgaW5wdXR0ZWQgVENQIGNvbm5lY3Rpb24gaW50byBXZWJTb2NrZXQgY29ubmVjdGlvbi4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhY2NlcHRXZWJTb2NrZXQocmVxOiB7XG4gIGNvbm46IERlbm8uQ29ubjtcbiAgYnVmV3JpdGVyOiBCdWZXcml0ZXI7XG4gIGJ1ZlJlYWRlcjogQnVmUmVhZGVyO1xuICBoZWFkZXJzOiBIZWFkZXJzO1xufSk6IFByb21pc2U8V2ViU29ja2V0PiB7XG4gIGNvbnN0IHsgY29ubiwgaGVhZGVycywgYnVmUmVhZGVyLCBidWZXcml0ZXIgfSA9IHJlcTtcbiAgaWYgKGFjY2VwdGFibGUocmVxKSkge1xuICAgIGNvbnN0IHNvY2sgPSBuZXcgV2ViU29ja2V0SW1wbCh7IGNvbm4sIGJ1ZlJlYWRlciwgYnVmV3JpdGVyIH0pO1xuICAgIGNvbnN0IHNlY0tleSA9IGhlYWRlcnMuZ2V0KFwic2VjLXdlYnNvY2tldC1rZXlcIik7XG4gICAgaWYgKHR5cGVvZiBzZWNLZXkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInNlYy13ZWJzb2NrZXQta2V5IGlzIG5vdCBwcm92aWRlZFwiKTtcbiAgICB9XG4gICAgY29uc3Qgc2VjQWNjZXB0ID0gY3JlYXRlU2VjQWNjZXB0KHNlY0tleSk7XG4gICAgY29uc3QgbmV3SGVhZGVycyA9IG5ldyBIZWFkZXJzKHtcbiAgICAgIFVwZ3JhZGU6IFwid2Vic29ja2V0XCIsXG4gICAgICBDb25uZWN0aW9uOiBcIlVwZ3JhZGVcIixcbiAgICAgIFwiU2VjLVdlYlNvY2tldC1BY2NlcHRcIjogc2VjQWNjZXB0LFxuICAgIH0pO1xuICAgIGNvbnN0IHNlY1Byb3RvY29sID0gaGVhZGVycy5nZXQoXCJzZWMtd2Vic29ja2V0LXByb3RvY29sXCIpO1xuICAgIGlmICh0eXBlb2Ygc2VjUHJvdG9jb2wgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIG5ld0hlYWRlcnMuc2V0KFwiU2VjLVdlYlNvY2tldC1Qcm90b2NvbFwiLCBzZWNQcm90b2NvbCk7XG4gICAgfVxuICAgIGNvbnN0IHNlY1ZlcnNpb24gPSBoZWFkZXJzLmdldChcInNlYy13ZWJzb2NrZXQtdmVyc2lvblwiKTtcbiAgICBpZiAodHlwZW9mIHNlY1ZlcnNpb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIG5ld0hlYWRlcnMuc2V0KFwiU2VjLVdlYlNvY2tldC1WZXJzaW9uXCIsIHNlY1ZlcnNpb24pO1xuICAgIH1cbiAgICBhd2FpdCB3cml0ZVJlc3BvbnNlKGJ1ZldyaXRlciwge1xuICAgICAgc3RhdHVzOiAxMDEsXG4gICAgICBoZWFkZXJzOiBuZXdIZWFkZXJzLFxuICAgIH0pO1xuICAgIHJldHVybiBzb2NrO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcInJlcXVlc3QgaXMgbm90IGFjY2VwdGFibGVcIik7XG59XG5cbmNvbnN0IGtTZWNDaGFycyA9IFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWi0ufl9cIjtcblxuLyoqIFJldHVybnMgYmFzZTY0IGVuY29kZWQgMTYgYnl0ZXMgc3RyaW5nIGZvciBTZWMtV2ViU29ja2V0LUtleSBoZWFkZXIuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2VjS2V5KCk6IHN0cmluZyB7XG4gIGxldCBrZXkgPSBcIlwiO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICBjb25zdCBqID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICoga1NlY0NoYXJzLmxlbmd0aCk7XG4gICAga2V5ICs9IGtTZWNDaGFyc1tqXTtcbiAgfVxuICByZXR1cm4gYnRvYShrZXkpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaGFuZHNoYWtlKFxuICB1cmw6IFVSTCxcbiAgaGVhZGVyczogSGVhZGVycyxcbiAgYnVmUmVhZGVyOiBCdWZSZWFkZXIsXG4gIGJ1ZldyaXRlcjogQnVmV3JpdGVyLFxuKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IHsgaG9zdG5hbWUsIHBhdGhuYW1lLCBzZWFyY2ggfSA9IHVybDtcbiAgY29uc3Qga2V5ID0gY3JlYXRlU2VjS2V5KCk7XG5cbiAgaWYgKCFoZWFkZXJzLmhhcyhcImhvc3RcIikpIHtcbiAgICBoZWFkZXJzLnNldChcImhvc3RcIiwgaG9zdG5hbWUpO1xuICB9XG4gIGhlYWRlcnMuc2V0KFwidXBncmFkZVwiLCBcIndlYnNvY2tldFwiKTtcbiAgaGVhZGVycy5zZXQoXCJjb25uZWN0aW9uXCIsIFwidXBncmFkZVwiKTtcbiAgaGVhZGVycy5zZXQoXCJzZWMtd2Vic29ja2V0LWtleVwiLCBrZXkpO1xuICBoZWFkZXJzLnNldChcInNlYy13ZWJzb2NrZXQtdmVyc2lvblwiLCBcIjEzXCIpO1xuXG4gIGxldCBoZWFkZXJTdHIgPSBgR0VUICR7cGF0aG5hbWV9JHtzZWFyY2h9IEhUVFAvMS4xXFxyXFxuYDtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgaGVhZGVycykge1xuICAgIGhlYWRlclN0ciArPSBgJHtrZXl9OiAke3ZhbHVlfVxcclxcbmA7XG4gIH1cbiAgaGVhZGVyU3RyICs9IFwiXFxyXFxuXCI7XG5cbiAgYXdhaXQgYnVmV3JpdGVyLndyaXRlKGVuY29kZShoZWFkZXJTdHIpKTtcbiAgYXdhaXQgYnVmV3JpdGVyLmZsdXNoKCk7XG5cbiAgY29uc3QgdHBSZWFkZXIgPSBuZXcgVGV4dFByb3RvUmVhZGVyKGJ1ZlJlYWRlcik7XG4gIGNvbnN0IHN0YXR1c0xpbmUgPSBhd2FpdCB0cFJlYWRlci5yZWFkTGluZSgpO1xuICBpZiAoc3RhdHVzTGluZSA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBEZW5vLmVycm9ycy5VbmV4cGVjdGVkRW9mKCk7XG4gIH1cbiAgY29uc3QgbSA9IHN0YXR1c0xpbmUubWF0Y2goL14oPzx2ZXJzaW9uPlxcUyspICg/PHN0YXR1c0NvZGU+XFxTKykgLyk7XG4gIGlmICghbSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIndzOiBpbnZhbGlkIHN0YXR1cyBsaW5lOiBcIiArIHN0YXR1c0xpbmUpO1xuICB9XG5cbiAgYXNzZXJ0KG0uZ3JvdXBzKTtcbiAgY29uc3QgeyB2ZXJzaW9uLCBzdGF0dXNDb2RlIH0gPSBtLmdyb3VwcztcbiAgaWYgKHZlcnNpb24gIT09IFwiSFRUUC8xLjFcIiB8fCBzdGF0dXNDb2RlICE9PSBcIjEwMVwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYHdzOiBzZXJ2ZXIgZGlkbid0IGFjY2VwdCBoYW5kc2hha2U6IGAgK1xuICAgICAgICBgdmVyc2lvbj0ke3ZlcnNpb259LCBzdGF0dXNDb2RlPSR7c3RhdHVzQ29kZX1gLFxuICAgICk7XG4gIH1cblxuICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBhd2FpdCB0cFJlYWRlci5yZWFkTUlNRUhlYWRlcigpO1xuICBpZiAocmVzcG9uc2VIZWFkZXJzID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IERlbm8uZXJyb3JzLlVuZXhwZWN0ZWRFb2YoKTtcbiAgfVxuXG4gIGNvbnN0IGV4cGVjdGVkU2VjQWNjZXB0ID0gY3JlYXRlU2VjQWNjZXB0KGtleSk7XG4gIGNvbnN0IHNlY0FjY2VwdCA9IHJlc3BvbnNlSGVhZGVycy5nZXQoXCJzZWMtd2Vic29ja2V0LWFjY2VwdFwiKTtcbiAgaWYgKHNlY0FjY2VwdCAhPT0gZXhwZWN0ZWRTZWNBY2NlcHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgd3M6IHVuZXhwZWN0ZWQgc2VjLXdlYnNvY2tldC1hY2NlcHQgaGVhZGVyOiBgICtcbiAgICAgICAgYGV4cGVjdGVkPSR7ZXhwZWN0ZWRTZWNBY2NlcHR9LCBhY3R1YWw9JHtzZWNBY2NlcHR9YCxcbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVXZWJTb2NrZXQocGFyYW1zOiB7XG4gIGNvbm46IERlbm8uQ29ubjtcbiAgYnVmV3JpdGVyPzogQnVmV3JpdGVyO1xuICBidWZSZWFkZXI/OiBCdWZSZWFkZXI7XG4gIG1hc2s/OiBVaW50OEFycmF5O1xufSk6IFdlYlNvY2tldCB7XG4gIHJldHVybiBuZXcgV2ViU29ja2V0SW1wbChwYXJhbXMpO1xufVxuIl19