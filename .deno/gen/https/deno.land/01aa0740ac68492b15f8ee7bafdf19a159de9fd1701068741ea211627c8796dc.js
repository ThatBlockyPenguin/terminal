import { concat } from "../bytes/mod.ts";
// Constants created for DRY
const CHAR_SPACE = " ".charCodeAt(0);
const CHAR_TAB = "\t".charCodeAt(0);
const CHAR_COLON = ":".charCodeAt(0);
const WHITESPACES = [
    CHAR_SPACE,
    CHAR_TAB
];
const decoder = new TextDecoder();
// FROM https://github.com/denoland/deno/blob/b34628a26ab0187a827aa4ebe256e23178e25d39/cli/js/web/headers.ts#L9
const invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/g;
function str(buf) {
    return !buf ? "" : decoder.decode(buf);
}
export class TextProtoReader {
    r;
    constructor(r){
        this.r = r;
    }
    /** readLine() reads a single line from the TextProtoReader,
   * eliding the final \n or \r\n from the returned string.
   */ async readLine() {
        const s = await this.readLineSlice();
        return s === null ? null : str(s);
    }
    /** ReadMIMEHeader reads a MIME-style header from r.
   * The header is a sequence of possibly continued Key: Value lines
   * ending in a blank line.
   * The returned map m maps CanonicalMIMEHeaderKey(key) to a
   * sequence of values in the same order encountered in the input.
   *
   * For example, consider this input:
   *
   *	My-Key: Value 1
   *	Long-Key: Even
   *	       Longer Value
   *	My-Key: Value 2
   *
   * Given that input, ReadMIMEHeader returns the map:
   *
   *	map[string][]string{
   *		"My-Key": {"Value 1", "Value 2"},
   *		"Long-Key": {"Even Longer Value"},
   *	}
   */ async readMIMEHeader() {
        const m = new Headers();
        let line;
        // The first line cannot start with a leading space.
        let buf = await this.r.peek(1);
        if (buf === null) {
            return null;
        } else if (WHITESPACES.includes(buf[0])) {
            line = await this.readLineSlice();
        }
        buf = await this.r.peek(1);
        if (buf === null) {
            throw new Deno.errors.UnexpectedEof();
        } else if (WHITESPACES.includes(buf[0])) {
            throw new Deno.errors.InvalidData(`malformed MIME header initial line: ${str(line)}`);
        }
        while(true){
            const kv = await this.readLineSlice(); // readContinuedLineSlice
            if (kv === null) throw new Deno.errors.UnexpectedEof();
            if (kv.byteLength === 0) return m;
            // Key ends at first colon
            let i = kv.indexOf(CHAR_COLON);
            if (i < 0) {
                throw new Deno.errors.InvalidData(`malformed MIME header line: ${str(kv)}`);
            }
            //let key = canonicalMIMEHeaderKey(kv.subarray(0, endKey));
            const key = str(kv.subarray(0, i));
            // As per RFC 7230 field-name is a token,
            // tokens consist of one or more chars.
            // We could throw `Deno.errors.InvalidData` here,
            // but better to be liberal in what we
            // accept, so if we get an empty key, skip it.
            if (key == "") {
                continue;
            }
            // Skip initial spaces in value.
            i++; // skip colon
            while(i < kv.byteLength && WHITESPACES.includes(kv[i])){
                i++;
            }
            const value = str(kv.subarray(i)).replace(invalidHeaderCharRegex, encodeURI);
            // In case of invalid header we swallow the error
            // example: "Audio Mode" => invalid due to space in the key
            try {
                m.append(key, value);
            } catch  {
            // Pass
            }
        }
    }
    async readLineSlice() {
        let line = new Uint8Array(0);
        let r = null;
        do {
            r = await this.r.readLine();
            // TODO(ry):
            // This skipSpace() is definitely misplaced, but I don't know where it
            // comes from nor how to fix it.
            //TODO(SmashingQuasar): Kept skipSpace to preserve behavior but it should be looked into to check if it makes sense when this is used.
            if (r !== null && this.skipSpace(r.line) !== 0) {
                line = concat(line, r.line);
            }
        }while (r !== null && r.more)
        return r === null ? null : line;
    }
    skipSpace(l) {
        let n = 0;
        for (const val of l){
            if (!WHITESPACES.includes(val)) {
                n++;
            }
        }
        return n;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImh0dHBzOi8vZGVuby5sYW5kL3N0ZEAwLjk5LjAvdGV4dHByb3RvL21vZC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxOC0yMDIxIHRoZSBEZW5vIGF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIE1JVCBsaWNlbnNlLlxuLy8gQmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2dvbGFuZy9nby90cmVlL21hc3Rlci9zcmMvbmV0L3RleHRwcm90b1xuLy8gQ29weXJpZ2h0IDIwMDkgVGhlIEdvIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZVxuLy8gbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlLlxuXG5pbXBvcnQgdHlwZSB7IEJ1ZlJlYWRlciwgUmVhZExpbmVSZXN1bHQgfSBmcm9tIFwiLi4vaW8vYnVmaW8udHNcIjtcbmltcG9ydCB7IGNvbmNhdCB9IGZyb20gXCIuLi9ieXRlcy9tb2QudHNcIjtcblxuLy8gQ29uc3RhbnRzIGNyZWF0ZWQgZm9yIERSWVxuY29uc3QgQ0hBUl9TUEFDRTogbnVtYmVyID0gXCIgXCIuY2hhckNvZGVBdCgwKTtcbmNvbnN0IENIQVJfVEFCOiBudW1iZXIgPSBcIlxcdFwiLmNoYXJDb2RlQXQoMCk7XG5jb25zdCBDSEFSX0NPTE9OOiBudW1iZXIgPSBcIjpcIi5jaGFyQ29kZUF0KDApO1xuXG5jb25zdCBXSElURVNQQUNFUzogQXJyYXk8bnVtYmVyPiA9IFtDSEFSX1NQQUNFLCBDSEFSX1RBQl07XG5cbmNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcblxuLy8gRlJPTSBodHRwczovL2dpdGh1Yi5jb20vZGVub2xhbmQvZGVuby9ibG9iL2IzNDYyOGEyNmFiMDE4N2E4MjdhYTRlYmUyNTZlMjMxNzhlMjVkMzkvY2xpL2pzL3dlYi9oZWFkZXJzLnRzI0w5XG5jb25zdCBpbnZhbGlkSGVhZGVyQ2hhclJlZ2V4ID0gL1teXFx0XFx4MjAtXFx4N2VcXHg4MC1cXHhmZl0vZztcblxuZnVuY3Rpb24gc3RyKGJ1ZjogVWludDhBcnJheSB8IG51bGwgfCB1bmRlZmluZWQpOiBzdHJpbmcge1xuICByZXR1cm4gIWJ1ZiA/IFwiXCIgOiBkZWNvZGVyLmRlY29kZShidWYpO1xufVxuXG5leHBvcnQgY2xhc3MgVGV4dFByb3RvUmVhZGVyIHtcbiAgY29uc3RydWN0b3IocmVhZG9ubHkgcjogQnVmUmVhZGVyKSB7fVxuXG4gIC8qKiByZWFkTGluZSgpIHJlYWRzIGEgc2luZ2xlIGxpbmUgZnJvbSB0aGUgVGV4dFByb3RvUmVhZGVyLFxuICAgKiBlbGlkaW5nIHRoZSBmaW5hbCBcXG4gb3IgXFxyXFxuIGZyb20gdGhlIHJldHVybmVkIHN0cmluZy5cbiAgICovXG4gIGFzeW5jIHJlYWRMaW5lKCk6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xuICAgIGNvbnN0IHMgPSBhd2FpdCB0aGlzLnJlYWRMaW5lU2xpY2UoKTtcbiAgICByZXR1cm4gcyA9PT0gbnVsbCA/IG51bGwgOiBzdHIocyk7XG4gIH1cblxuICAvKiogUmVhZE1JTUVIZWFkZXIgcmVhZHMgYSBNSU1FLXN0eWxlIGhlYWRlciBmcm9tIHIuXG4gICAqIFRoZSBoZWFkZXIgaXMgYSBzZXF1ZW5jZSBvZiBwb3NzaWJseSBjb250aW51ZWQgS2V5OiBWYWx1ZSBsaW5lc1xuICAgKiBlbmRpbmcgaW4gYSBibGFuayBsaW5lLlxuICAgKiBUaGUgcmV0dXJuZWQgbWFwIG0gbWFwcyBDYW5vbmljYWxNSU1FSGVhZGVyS2V5KGtleSkgdG8gYVxuICAgKiBzZXF1ZW5jZSBvZiB2YWx1ZXMgaW4gdGhlIHNhbWUgb3JkZXIgZW5jb3VudGVyZWQgaW4gdGhlIGlucHV0LlxuICAgKlxuICAgKiBGb3IgZXhhbXBsZSwgY29uc2lkZXIgdGhpcyBpbnB1dDpcbiAgICpcbiAgICpcdE15LUtleTogVmFsdWUgMVxuICAgKlx0TG9uZy1LZXk6IEV2ZW5cbiAgICpcdCAgICAgICBMb25nZXIgVmFsdWVcbiAgICpcdE15LUtleTogVmFsdWUgMlxuICAgKlxuICAgKiBHaXZlbiB0aGF0IGlucHV0LCBSZWFkTUlNRUhlYWRlciByZXR1cm5zIHRoZSBtYXA6XG4gICAqXG4gICAqXHRtYXBbc3RyaW5nXVtdc3RyaW5ne1xuICAgKlx0XHRcIk15LUtleVwiOiB7XCJWYWx1ZSAxXCIsIFwiVmFsdWUgMlwifSxcbiAgICpcdFx0XCJMb25nLUtleVwiOiB7XCJFdmVuIExvbmdlciBWYWx1ZVwifSxcbiAgICpcdH1cbiAgICovXG4gIGFzeW5jIHJlYWRNSU1FSGVhZGVyKCk6IFByb21pc2U8SGVhZGVycyB8IG51bGw+IHtcbiAgICBjb25zdCBtID0gbmV3IEhlYWRlcnMoKTtcbiAgICBsZXQgbGluZTogVWludDhBcnJheSB8IHVuZGVmaW5lZDtcblxuICAgIC8vIFRoZSBmaXJzdCBsaW5lIGNhbm5vdCBzdGFydCB3aXRoIGEgbGVhZGluZyBzcGFjZS5cbiAgICBsZXQgYnVmID0gYXdhaXQgdGhpcy5yLnBlZWsoMSk7XG4gICAgaWYgKGJ1ZiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIGlmIChXSElURVNQQUNFUy5pbmNsdWRlcyhidWZbMF0pKSB7XG4gICAgICBsaW5lID0gKGF3YWl0IHRoaXMucmVhZExpbmVTbGljZSgpKSBhcyBVaW50OEFycmF5O1xuICAgIH1cblxuICAgIGJ1ZiA9IGF3YWl0IHRoaXMuci5wZWVrKDEpO1xuICAgIGlmIChidWYgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBEZW5vLmVycm9ycy5VbmV4cGVjdGVkRW9mKCk7XG4gICAgfSBlbHNlIGlmIChXSElURVNQQUNFUy5pbmNsdWRlcyhidWZbMF0pKSB7XG4gICAgICB0aHJvdyBuZXcgRGVuby5lcnJvcnMuSW52YWxpZERhdGEoXG4gICAgICAgIGBtYWxmb3JtZWQgTUlNRSBoZWFkZXIgaW5pdGlhbCBsaW5lOiAke3N0cihsaW5lKX1gLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3Qga3YgPSBhd2FpdCB0aGlzLnJlYWRMaW5lU2xpY2UoKTsgLy8gcmVhZENvbnRpbnVlZExpbmVTbGljZVxuICAgICAgaWYgKGt2ID09PSBudWxsKSB0aHJvdyBuZXcgRGVuby5lcnJvcnMuVW5leHBlY3RlZEVvZigpO1xuICAgICAgaWYgKGt2LmJ5dGVMZW5ndGggPT09IDApIHJldHVybiBtO1xuXG4gICAgICAvLyBLZXkgZW5kcyBhdCBmaXJzdCBjb2xvblxuICAgICAgbGV0IGkgPSBrdi5pbmRleE9mKENIQVJfQ09MT04pO1xuICAgICAgaWYgKGkgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBEZW5vLmVycm9ycy5JbnZhbGlkRGF0YShcbiAgICAgICAgICBgbWFsZm9ybWVkIE1JTUUgaGVhZGVyIGxpbmU6ICR7c3RyKGt2KX1gLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvL2xldCBrZXkgPSBjYW5vbmljYWxNSU1FSGVhZGVyS2V5KGt2LnN1YmFycmF5KDAsIGVuZEtleSkpO1xuICAgICAgY29uc3Qga2V5ID0gc3RyKGt2LnN1YmFycmF5KDAsIGkpKTtcblxuICAgICAgLy8gQXMgcGVyIFJGQyA3MjMwIGZpZWxkLW5hbWUgaXMgYSB0b2tlbixcbiAgICAgIC8vIHRva2VucyBjb25zaXN0IG9mIG9uZSBvciBtb3JlIGNoYXJzLlxuICAgICAgLy8gV2UgY291bGQgdGhyb3cgYERlbm8uZXJyb3JzLkludmFsaWREYXRhYCBoZXJlLFxuICAgICAgLy8gYnV0IGJldHRlciB0byBiZSBsaWJlcmFsIGluIHdoYXQgd2VcbiAgICAgIC8vIGFjY2VwdCwgc28gaWYgd2UgZ2V0IGFuIGVtcHR5IGtleSwgc2tpcCBpdC5cbiAgICAgIGlmIChrZXkgPT0gXCJcIikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gU2tpcCBpbml0aWFsIHNwYWNlcyBpbiB2YWx1ZS5cbiAgICAgIGkrKzsgLy8gc2tpcCBjb2xvblxuICAgICAgd2hpbGUgKFxuICAgICAgICBpIDwga3YuYnl0ZUxlbmd0aCAmJlxuICAgICAgICAoV0hJVEVTUEFDRVMuaW5jbHVkZXMoa3ZbaV0pKVxuICAgICAgKSB7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlID0gc3RyKGt2LnN1YmFycmF5KGkpKS5yZXBsYWNlKFxuICAgICAgICBpbnZhbGlkSGVhZGVyQ2hhclJlZ2V4LFxuICAgICAgICBlbmNvZGVVUkksXG4gICAgICApO1xuXG4gICAgICAvLyBJbiBjYXNlIG9mIGludmFsaWQgaGVhZGVyIHdlIHN3YWxsb3cgdGhlIGVycm9yXG4gICAgICAvLyBleGFtcGxlOiBcIkF1ZGlvIE1vZGVcIiA9PiBpbnZhbGlkIGR1ZSB0byBzcGFjZSBpbiB0aGUga2V5XG4gICAgICB0cnkge1xuICAgICAgICBtLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICAvLyBQYXNzXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgcmVhZExpbmVTbGljZSgpOiBQcm9taXNlPFVpbnQ4QXJyYXkgfCBudWxsPiB7XG4gICAgbGV0IGxpbmUgPSBuZXcgVWludDhBcnJheSgwKTtcbiAgICBsZXQgcjogUmVhZExpbmVSZXN1bHQgfCBudWxsID0gbnVsbDtcblxuICAgIGRvIHtcbiAgICAgIHIgPSBhd2FpdCB0aGlzLnIucmVhZExpbmUoKTtcbiAgICAgIC8vIFRPRE8ocnkpOlxuICAgICAgLy8gVGhpcyBza2lwU3BhY2UoKSBpcyBkZWZpbml0ZWx5IG1pc3BsYWNlZCwgYnV0IEkgZG9uJ3Qga25vdyB3aGVyZSBpdFxuICAgICAgLy8gY29tZXMgZnJvbSBub3IgaG93IHRvIGZpeCBpdC5cblxuICAgICAgLy9UT0RPKFNtYXNoaW5nUXVhc2FyKTogS2VwdCBza2lwU3BhY2UgdG8gcHJlc2VydmUgYmVoYXZpb3IgYnV0IGl0IHNob3VsZCBiZSBsb29rZWQgaW50byB0byBjaGVjayBpZiBpdCBtYWtlcyBzZW5zZSB3aGVuIHRoaXMgaXMgdXNlZC5cblxuICAgICAgaWYgKHIgIT09IG51bGwgJiYgdGhpcy5za2lwU3BhY2Uoci5saW5lKSAhPT0gMCkge1xuICAgICAgICBsaW5lID0gY29uY2F0KGxpbmUsIHIubGluZSk7XG4gICAgICB9XG4gICAgfSB3aGlsZSAociAhPT0gbnVsbCAmJiByLm1vcmUpO1xuXG4gICAgcmV0dXJuIHIgPT09IG51bGwgPyBudWxsIDogbGluZTtcbiAgfVxuXG4gIHNraXBTcGFjZShsOiBVaW50OEFycmF5KTogbnVtYmVyIHtcbiAgICBsZXQgbiA9IDA7XG5cbiAgICBmb3IgKGNvbnN0IHZhbCBvZiBsKSB7XG4gICAgICBpZiAoIVdISVRFU1BBQ0VTLmluY2x1ZGVzKHZhbCkpIHtcbiAgICAgICAgbisrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBT0EsTUFBTSxHQUFHLE1BQU0sUUFBUSxDQUFpQjtBQUV4QyxFQUE0QixBQUE1QiwwQkFBNEI7QUFDNUIsS0FBSyxDQUFDLFVBQVUsR0FBVyxDQUFHLEdBQUMsVUFBVSxDQUFDLENBQUM7QUFDM0MsS0FBSyxDQUFDLFFBQVEsR0FBVyxDQUFJLElBQUMsVUFBVSxDQUFDLENBQUM7QUFDMUMsS0FBSyxDQUFDLFVBQVUsR0FBVyxDQUFHLEdBQUMsVUFBVSxDQUFDLENBQUM7QUFFM0MsS0FBSyxDQUFDLFdBQVcsR0FBa0IsQ0FBQztJQUFBLFVBQVU7SUFBRSxRQUFRO0FBQUEsQ0FBQztBQUV6RCxLQUFLLENBQUMsT0FBTyxHQUFHLEdBQUcsQ0FBQyxXQUFXO0FBRS9CLEVBQStHLEFBQS9HLDZHQUErRztBQUMvRyxLQUFLLENBQUMsc0JBQXNCO1NBRW5CLEdBQUcsQ0FBQyxHQUFrQyxFQUFVLENBQUM7SUFDeEQsTUFBTSxFQUFFLEdBQUcsR0FBRyxDQUFFLElBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxHQUFHO0FBQ3ZDLENBQUM7QUFFRCxNQUFNLE9BQU8sZUFBZTtJQUNMLENBQVk7Z0JBQVosQ0FBWSxDQUFFLENBQUM7YUFBZixDQUFZLEdBQVosQ0FBWTtJQUFHLENBQUM7SUFFckMsRUFFRyxBQUZIOztHQUVHLEFBRkgsRUFFRyxPQUNHLFFBQVEsR0FBMkIsQ0FBQztRQUN4QyxLQUFLLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsYUFBYTtRQUNsQyxNQUFNLENBQUMsQ0FBQyxLQUFLLElBQUksR0FBRyxJQUFJLEdBQUcsR0FBRyxDQUFDLENBQUM7SUFDbEMsQ0FBQztJQUVELEVBbUJHLEFBbkJIOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBbUJHLEFBbkJILEVBbUJHLE9BQ0csY0FBYyxHQUE0QixDQUFDO1FBQy9DLEtBQUssQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLE9BQU87UUFDckIsR0FBRyxDQUFDLElBQUk7UUFFUixFQUFvRCxBQUFwRCxrREFBb0Q7UUFDcEQsR0FBRyxDQUFDLEdBQUcsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUM3QixFQUFFLEVBQUUsR0FBRyxLQUFLLElBQUksRUFBRSxDQUFDO1lBQ2pCLE1BQU0sQ0FBQyxJQUFJO1FBQ2IsQ0FBQyxNQUFNLEVBQUUsRUFBRSxXQUFXLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQztZQUN4QyxJQUFJLEdBQUksS0FBSyxDQUFDLElBQUksQ0FBQyxhQUFhO1FBQ2xDLENBQUM7UUFFRCxHQUFHLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDekIsRUFBRSxFQUFFLEdBQUcsS0FBSyxJQUFJLEVBQUUsQ0FBQztZQUNqQixLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsYUFBYTtRQUNyQyxDQUFDLE1BQU0sRUFBRSxFQUFFLFdBQVcsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDO1lBQ3hDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxXQUFXLEVBQzlCLG9DQUFvQyxFQUFFLEdBQUcsQ0FBQyxJQUFJO1FBRW5ELENBQUM7Y0FFTSxJQUFJLENBQUUsQ0FBQztZQUNaLEtBQUssQ0FBQyxFQUFFLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxhQUFhLEdBQUksQ0FBeUIsQUFBekIsRUFBeUIsQUFBekIsdUJBQXlCO1lBQ2hFLEVBQUUsRUFBRSxFQUFFLEtBQUssSUFBSSxFQUFFLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxhQUFhO1lBQ3BELEVBQUUsRUFBRSxFQUFFLENBQUMsVUFBVSxLQUFLLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQztZQUVqQyxFQUEwQixBQUExQix3QkFBMEI7WUFDMUIsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsT0FBTyxDQUFDLFVBQVU7WUFDN0IsRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQztnQkFDVixLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsV0FBVyxFQUM5Qiw0QkFBNEIsRUFBRSxHQUFHLENBQUMsRUFBRTtZQUV6QyxDQUFDO1lBRUQsRUFBMkQsQUFBM0QseURBQTJEO1lBQzNELEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLENBQUM7WUFFaEMsRUFBeUMsQUFBekMsdUNBQXlDO1lBQ3pDLEVBQXVDLEFBQXZDLHFDQUF1QztZQUN2QyxFQUFpRCxBQUFqRCwrQ0FBaUQ7WUFDakQsRUFBc0MsQUFBdEMsb0NBQXNDO1lBQ3RDLEVBQThDLEFBQTlDLDRDQUE4QztZQUM5QyxFQUFFLEVBQUUsR0FBRyxJQUFJLENBQUUsR0FBRSxDQUFDO2dCQUNkLFFBQVE7WUFDVixDQUFDO1lBRUQsRUFBZ0MsQUFBaEMsOEJBQWdDO1lBQ2hDLENBQUMsR0FBSSxDQUFhLEFBQWIsRUFBYSxBQUFiLFdBQWE7a0JBRWhCLENBQUMsR0FBRyxFQUFFLENBQUMsVUFBVSxJQUNoQixXQUFXLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQzFCLENBQUM7Z0JBQ0QsQ0FBQztZQUNILENBQUM7WUFDRCxLQUFLLENBQUMsS0FBSyxHQUFHLEdBQUcsQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxPQUFPLENBQ3ZDLHNCQUFzQixFQUN0QixTQUFTO1lBR1gsRUFBaUQsQUFBakQsK0NBQWlEO1lBQ2pELEVBQTJELEFBQTNELHlEQUEyRDtZQUMzRCxHQUFHLENBQUMsQ0FBQztnQkFDSCxDQUFDLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxLQUFLO1lBQ3JCLENBQUMsQ0FBQyxLQUFLLEVBQUMsQ0FBQztZQUNQLEVBQU8sQUFBUCxLQUFPO1lBQ1QsQ0FBQztRQUNILENBQUM7SUFDSCxDQUFDO1VBRUssYUFBYSxHQUErQixDQUFDO1FBQ2pELEdBQUcsQ0FBQyxJQUFJLEdBQUcsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQzNCLEdBQUcsQ0FBQyxDQUFDLEdBQTBCLElBQUk7V0FFaEMsQ0FBQztZQUNGLENBQUMsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRO1lBQ3pCLEVBQVksQUFBWixVQUFZO1lBQ1osRUFBc0UsQUFBdEUsb0VBQXNFO1lBQ3RFLEVBQWdDLEFBQWhDLDhCQUFnQztZQUVoQyxFQUFzSSxBQUF0SSxvSUFBc0k7WUFFdEksRUFBRSxFQUFFLENBQUMsS0FBSyxJQUFJLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUMsRUFBRSxDQUFDO2dCQUMvQyxJQUFJLEdBQUcsTUFBTSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsSUFBSTtZQUM1QixDQUFDO1FBQ0gsQ0FBQyxPQUFRLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxDQUFDLElBQUk7UUFFN0IsTUFBTSxDQUFDLENBQUMsS0FBSyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUk7SUFDakMsQ0FBQztJQUVELFNBQVMsQ0FBQyxDQUFhLEVBQVUsQ0FBQztRQUNoQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUM7UUFFVCxHQUFHLEVBQUUsS0FBSyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUUsQ0FBQztZQUNwQixFQUFFLEdBQUcsV0FBVyxDQUFDLFFBQVEsQ0FBQyxHQUFHLEdBQUcsQ0FBQztnQkFDL0IsQ0FBQztZQUNILENBQUM7UUFDSCxDQUFDO1FBRUQsTUFBTSxDQUFDLENBQUM7SUFDVixDQUFDIn0=